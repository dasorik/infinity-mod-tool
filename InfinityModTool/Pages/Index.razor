@page "/"
@page "/mods"
@page "/mods/{category}"
@using System.IO;
@inject InfinityModTool.Services.ModService modService;
@inject Tewr.Blazor.FileReader.IFileReaderService fileReaderService;

@using InfinityModTool.Utilities;


@if (showLoadingIcon)
{
    <LoadingScreen></LoadingScreen>
}

@if (confirmConfig?.CanShow ?? false)
{
    <PopupConfirm Type="@confirmConfig.level" Title="@confirmConfig.title" Message="@confirmConfig.message" ConfirmedChanged="async (confirmed) => { confirmConfig.Hide(); if (confirmed) await confirmConfig.confirmAction?.Invoke(); }"></PopupConfirm>
}

@if (replaceConfig?.CanShow ?? false)
{
    <PopupConfirmReplace Type="@replaceConfig.level" Title="@replaceConfig.title" Message="@replaceConfig.message" ConfirmedPressed="async (id) => { replaceConfig.Hide(); await replaceConfig.confirmAction?.Invoke(id); }" CancelPressed="() => replaceConfig = null" Options="@modService.GetAvailableReplacementCharacters(installContext.ModID)"></PopupConfirmReplace>
}

@if (alertConfig?.CanShow ?? false)
{
    <PopupAlert Type="@alertConfig.level" Title="@alertConfig.title" Message="@alertConfig.message" OnDismissed="async () => { alertConfig.Hide(); if (alertConfig.confirmAction != null) { await alertConfig.confirmAction(); } }"></PopupAlert>
}

@if (!string.IsNullOrEmpty(warningMessage))
{
    <BannerAlert Type="Warning" Message="@warningMessage"></BannerAlert>
}

@foreach (var mod in mods)
{
    <CharacterButton IDName="@mod.ModID" DisplayName="@mod.DisplayName" DisplayImage="@mod.DisplayImageBase64" DisplayColor="@mod.DisplayColor" Icon="@modService.GetModIcon(mod.ModID)" Installed="@modService.IsModInstalled(mod.ModID)" OnClick="@SelectMod"></CharacterButton>
}

<label class="character-button no-drop-shadow">
    <input type="file" @ref=inputTypeFileElement @onchange="ReadFile" />
    <img src="img/add-new-mod.svg" class="new"/>
</label>

@code {
    [Parameter] public string category { get; set; }

    ElementReference inputTypeFileElement = new ElementReference();

    bool showLoadingIcon = false;
    ConfirmationDialogConfig confirmConfig = null;
    ConfirmationDialogConfig<string> replaceConfig = null;
    AlertDialogConfig alertConfig = null;

    bool install = false;
    bool requiresReplacement = false;
    InfinityModTool.Data.ModInstallationData installContext;

    string warningMessage = null;
    string alertMessage = null;

    IEnumerable<InfinityModTool.Data.BaseModConfiguration> mods = new InfinityModTool.Data.BaseModConfiguration[] { };

    protected override void OnParametersSet()
    {
        if (string.IsNullOrEmpty(modService.Settings.SteamInstallationPath))
            warningMessage = "Steam installation path has not been set, please set this via the settings tab";

        mods = modService.GetModsForCategory(category);
        CheckForUnloadedMods();
    }

    async Task ReadFile()
    {
        showLoadingIcon = true;

        Tewr.Blazor.FileReader.IFileReference fileReference = null;
        foreach (var file in await fileReaderService.CreateReference(inputTypeFileElement).EnumerateFilesAsync())
        {
            fileReference = file;
            break;
        }

        if (fileReference == null)
            return;

        byte[] fileBytes;
        string fileName;

        using (MemoryStream memoryStream = await fileReference.CreateMemoryStreamAsync(4096))
        {
            fileBytes = memoryStream.ToArray();
            fileName = (await fileReference.ReadFileInfoAsync()).Name;
        }

        var result = modService.TryAddMod(fileName, fileBytes);
        string errorMessage = null;

        switch (result)
        {
            case Enums.ModLoadStatus.ConfigInvalid:
                errorMessage = "The selected mod is not configured properly. Please check the config.json file";
                break;
            case Enums.ModLoadStatus.DuplicateID:
                errorMessage = "A mod with the same ID has already been added";
                break;
            case Enums.ModLoadStatus.ExtensionInvalid:
                errorMessage = "The selected mod is not a mod file";
                break;
            case Enums.ModLoadStatus.NoConfig:
                errorMessage = "No config could be found on the selected mod";
                break;
            case Enums.ModLoadStatus.UnspecifiedFailure:
                errorMessage = "An error occuring trying to load the selected mod";
                break;
            case Enums.ModLoadStatus.UnsupportedVersion:
                errorMessage = "The version number of this mod is not supported by this version of the mod installer";
                break;
        }

        if (!string.IsNullOrEmpty(errorMessage))
        {
            ShowAlertDialog(
                title: "Unable to load mod",
                message: errorMessage,
                level: AlertLevel.Error
            );
        }

        // Clear this
        inputTypeFileElement = new ElementReference();
        showLoadingIcon = false;

        mods = modService.GetModsForCategory(category); // We need to show the new list of mods
    }

    void CheckForUnloadedMods()
    {
        // Don't show if we've already shown
        if (modService.ModLoadWarningShown)
            return;

        var failedModLoads = modService.ModLoadResults.Where(r => new[] { Enums.ModLoadStatus.ConfigInvalid, Enums.ModLoadStatus.NoConfig, Enums.ModLoadStatus.UnspecifiedFailure, Enums.ModLoadStatus.UnsupportedVersion }.Contains(r.status));

        if (failedModLoads.Count() > 0)
        {
            ShowAlertDialog(
                title: "Mods Failed to Load",
                message: $"The following mods failed to load: {string.Join(", ", failedModLoads.Select(r => $"{r.modFileName} - {r.status}"))}",
                level: AlertLevel.Warning,
                onClick: async () => { modService.ModLoadWarningShown = true; }
            );
        }
    }

    void SelectMod(string modID)
    {
        if (string.IsNullOrEmpty(modService.Settings.SteamInstallationPath))
        {
            ShowAlertDialog(
                title: null,
                message: "Steam installation path has not been set, please set this in 'Settings'",
                level: AlertLevel.Info
            );

            return;
        }

        var modData = modService.GetMod(modID);
        install = !modService.IsModInstalled(modID);
        installContext = new Data.ModInstallationData() { ModID = modData.ModID, ModCategory = modData.ModCategory };

        if (modData.ModCategory == "Character")
            SelectCharacterMod(modData as Data.CharacterModConfiguration);
        else
            ShowInstallConfirmationDialog();
    }

    void SelectCharacterMod(Data.CharacterModConfiguration modData)
    {
        requiresReplacement = modData?.ReplaceCharacter ?? false;

        if (requiresReplacement && install)
            ShowReplaceConfirmationDialog();
        else
            ShowInstallConfirmationDialog();
    }

    void ShowInstallConfirmationDialog()
    {
        ShowConfirmDialog(
            title: GetInstallMessage(),
            message: "This will modify your Disney Infinity 3.0 game installation",
            level: AlertLevel.Warning,
            confirmAction: () => InstallUninstall(installContext)
        );
    }

    void ShowReplaceConfirmationDialog()
    {
        replaceConfig = new ConfirmationDialogConfig<string>()
        {
            title = GetInstallMessage(),
            message = "Please select a character below to replace, This will modify your Disney Infinity 3.0 game installation",
            level = AlertLevel.Warning,
            confirmAction = (id) => InstallUninstall(id, installContext)
        };

        replaceConfig.Show();
    }

    void ShowAlertDialog(string title, string message, AlertLevel level, Func<Task> onClick = null)
    {
        alertConfig = new AlertDialogConfig()
        {
            title = title,
            message = message,
            level = level,
            confirmAction = onClick
        };

        alertConfig.Show();
    }

    void ShowConfirmDialog(string title, string message, AlertLevel level, Func<Task> confirmAction)
    {
        confirmConfig = new ConfirmationDialogConfig()
        {
            title = title,
            message = message,
            level = level,
            confirmAction = confirmAction
        };

        confirmConfig.Show();
    }

    async Task InstallUninstall(string selectedCharacterID, Data.ModInstallationData modification, bool ignoreWarnings = false)
    {
        modification.Parameters.Add("ReplacementCharacter", selectedCharacterID);
        await InstallUninstall(modification, ignoreWarnings);
    }

    async Task InstallUninstall(Data.ModInstallationData modification, bool ignoreWarnings = false)
    {
        showLoadingIcon = true;

        InfinityModTool.Models.InstallInfo installStatus;

        if (install)
            installStatus = await modService.InstallCharacterMod(modification);
        else
            installStatus = await modService.UninstallMod(modification.ModID);

        switch (installStatus.status)
        {
            case Enums.InstallationStatus.FatalError:
            case Enums.InstallationStatus.RolledBackError:
                ShowAlertDialog(
                    title: "Oops, something went wrong!",
                    message: "Something went wrong during mod installation. All mods have been uninstalled, and your game has been restored",
                    level: AlertLevel.Error
                );
                break;
            case Enums.InstallationStatus.UnresolvableConflict:
                var conflictingMods = installStatus.conflicts.Select(m => m.mod.Config.DisplayName);
                ShowAlertDialog(
                    title: "Mod conflict detected",
                    message: $"The mod being installed conflicts with the following installed mod{(conflictingMods.Count() > 0 ? "s" : "")}, and has not been installed: {string.Join(", ", conflictingMods)}",
                    level: AlertLevel.Error
                );
                break;
            case Enums.InstallationStatus.ResolvableConflict:
                var potentialIssues = installStatus.conflicts.Select(m => m.mod.Config.DisplayName);
                ShowConfirmDialog(
                    title: $"Potential conflict{(potentialIssues.Count() > 0 ? "s" : "")} detected",
                    message: $"The mod being installed has potential conflicts with the following installed mod{(potentialIssues.Count() > 0 ? "s" : "")}: {string.Join(", ", potentialIssues)}\nInstall mod anyway?",
                    level: AlertLevel.Warning,
                    confirmAction: () => InstallUninstall(installContext, true)
                );
                break;
        }

        showLoadingIcon = false;
    }

    string GetInstallMessage()
    {
        return install ? "Install Mod?" : "Uninstall Mod?";
    }
}